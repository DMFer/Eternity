# **Linpack分析**

## 目录

### 	**1.[Linpack介绍](#Linpack介绍)**

### 	**2.[HPL测试原理](#HPL测试原理)**

### 	**3.[HPL算法描述](#HPL算法描述)**

### 	**4.[HPL代码分析](#HPL代码分析)**



---

# **Linpack介绍**

​    **Linpack**现在在国际上已经成为最流行的用于测试高性能计算机系统浮点性能的基准。通过利用高性能计算机，用高斯消元法求解N元一次稠密线性代数方程组的测试，评价高性能计算机的浮点性能。  

​	衡量计算机性能的一个重要指标就是**计算峰值**，例如浮点计算峰值，它是指计算机每秒钟能完成的浮点计算最大次数。包括理论浮点峰值和实测浮点峰值。**理论浮点峰值**是该计算机理论上能达到的每秒钟能完成浮点计算最大次数，它主要是由CPU的主频决定的。实测浮点峰值是指Linpack测试值。

​     **Linpack测试包括三类：**

###### 	* Linpack100：

​			其求解规模为100阶的稠密线性代数方程组，它只允许采用编译优化选项进行优化，不得更改代码，甚至代码中的注释也不得修改。 

###### 	* Linpack1000：

​			其要求求解规模为1000阶的线性代数方程组， 达到指定的精度要求，可以在不改变计算量的前提下做算法和代码上做优化。 

###### 	* HPL

​			HPL即High Performance Linpack，也叫高度并行计算基准测试。 它对数组大小N没有限制，求解问题的规模可以改变，除基本算法（计算量）不可改变外，可以采用其它任何优化方法。 

​	随着现代计算机的快速发展，前面两种测试方式也就是越来越不被重用了，由于HPL对数组大小没有限制，所以现代的并行计算机大部分是使用HPL作为测试标准。

​	我也就主要对HPL测试标准进行分析。



# HPL测试原理

### * 测试过程：
<span id="1"></span>
​	HPL测试就是利用高斯消元法求解线性方程组，所以假设求解的问题如下：

​	
$$
\left[
\begin{matrix}
 a_{11} & a_{12} & \cdots & a_{1n} \\
 a_{21} & a_{22} & \cdots & a_{2n} \\
 \vdots & \vdots & \ddots & \vdots \\
 a_{n1} & a_{n2} & \cdots & a_{nn} \\
\end{matrix}
\right].
\left[\begin{matrix}
 x_{1}  \\
 x_{2}  \\
 \vdots \\
 x_{n}  \\
 \end {matrix}
 \right]=
 \left[\begin{matrix}
 b_{1}  \\
 b_{2}  \\
 \vdots \\
 b_{n}  \\
 \end {matrix}
 \right]
$$
​	HPL是通过求解一个稠密线性方程组来测试计算机的性能，a矩阵是一个n*n的矩阵，b向量是一个n维的列向量，它们两个均是已知的，x向量也是一个n维的列向量，是要求解的。经过LU分解，就可以将求解方程组的问题转换为求解两个三角方程组。LU分解是我们在线性代数中学过的，矩阵A可以转化为LU，即A=LU，L是下三角矩阵，U是上三角矩阵。这实际上也就是通过高斯消元法来求解的，在进行高斯消元法后可以得到一个上三角矩阵，也就是U矩阵，其过程中的变换矩阵也就是L矩阵。

​	由A=LU可得，即 Ax=b就可以表示为LUx=b，令y=Ux，则Ly=b就可以求得y的值，再由Ux=y，求得x的值。计算公式如下：

​	
$$
\begin{cases}
y_{1}=b_{1} \\
y_{i}=b_{i}-\sum_{j=1}^{i-1} l_{ij}y_{j} &,&i=2,3,\cdots,n
\end{cases}
$$

$$
\begin{cases}
x_{n}=\frac{y_{n}}{U_{nn}} \\
x_{i}=\frac{(y_{i}-\sum_{j=i+1}^{n} U_{ij}x_{j})}{U_{ii}} &,& i=n-1,n-2,\cdots,1
\end{cases}
$$



### 	*计算速率：

​	通过上述式子就可以计算出线性方程组的解，然后统计计算大规模的稠密线性方程组耗费的时间，就可以求得计算浮点的速率。计算公式如下：
$$
R=\frac{\frac{2N^3}{3}+\frac{3N^2}{2}}{T_{HPL}} \ast 10^{-9} （GFLOPS）
$$
​	公式中 2N<sup>3</sup>/3+3N<sup>2</sup>/2表示的是浮点运算的规模， T<sub>HPL</sub>表示的是HPL测试程序执行的时间，也就是[测试过程](#1)中求n维列向量的时间，GFLOPS单位：每秒10亿次的浮点运算数（10<sup>9</sup>）。得到浮点速率后，与计算机的峰值相除（**计算机的峰值**是理论最大性能，是不可能达到的理想值，等于CPU主频 x CPU每个时钟周期执行浮点运算的次数 x 系统中CPU核心数目），就可以得到计算机的运行效率。



### 	*执行时间：

​	假设内存空间足够，不发生交换，也不考虑cache缺失，可以得到T<sub>HPL</sub>的值。计算公式如下：
$$
T_{HPL}=\frac{2N^3}{3PQγ}+\frac{\beta N^2(3P+Q)}{2PQ}+\frac{\alpha N((NB+1)\log (P)+P)}{NB}
$$
​	这个公式很复杂，α表示处理器之间进行一次通信的启动时间，β表示通信的速率，γ表示处理器的一个矩阵浮点运算的速率。

​	但是总的来说，T<sub>HPL</sub>主要分为两个部分，一部分是BLAS函数的执行时间，对应公式中的2N<sup>3</sup>/3PQγ，另一部分是广播通信的时间，对应公式中的后面那两部分，前者主要受BLAS函数库和cache缺失率的影响，后者主要受互联网路结构、PxQ（处理器网格的排列形式）、广播算法、MPI（消息传递接口）的影响。

# HPL算法描述

